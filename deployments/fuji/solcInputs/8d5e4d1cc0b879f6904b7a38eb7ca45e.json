{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/Lending/Lending.sol": {
      "content": "// SPDX-License-Identifier:MIT\n\npragma solidity ^0.8.9;\n\n// OpenZeppelin's ERC20 interface for interactions with ERC20 tokens.\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\n// Custom errors for specific failure conditions.\nerror lending_outOfReserve();\nerror lending_addressNotAllowed();\nerror lending_reserveNotAvailable();\nerror lending_notEnoughTimePassed();\n\n/**\n * @title Lending\n * @dev Implements lending and yield farming functionalities for a specific ERC20 token.\n * This contract allows tokens to be lent out and borrowed, tracks yield farming activities,\n * and allows for the accumulation and withdrawal of yield based on predefined APY.\n */\ncontract Lending {\n    // The ERC20 token used for lending and borrowing.\n    IERC20 public token;\n\n    // Address of the owner contract.\n    address public ownerContract;\n\n    // Total amount of tokens lent out.\n    uint256 public amoutLended;\n\n    // Available reserve for borrowing.\n    uint256 public reserve;\n\n    // Annual Percentage Yield for borrowing.\n    uint256 public borrowingAPY;\n\n    // Total yield generated.\n    uint256 public yield;\n\n    // Yield already farmed.\n    uint256 public farmedYield;\n\n    // Mapping of addresses to their last yield farming timestamp.\n    mapping(address => uint256) public lastYieldFarmedTime;\n\n    // Mapping of addresses to the amount of yield they have taken.\n    mapping(address => uint256) public yieldTaken;\n\n    /**\n     * @dev Ensures that only the owner contract can call the modified function.\n     */\n    modifier onlyOwner() {\n        if (msg.sender != ownerContract) {\n            revert lending_addressNotAllowed();\n        }\n        _;\n    }\n\n    /**\n     * @param _token The ERC20 token address for lending and borrowing.\n     */\n    constructor(address _token) {\n        token = IERC20(_token);\n        ownerContract = msg.sender;\n    }\n\n    /**\n     * @notice Allows the owner to borrow tokens from the reserve.\n     * @param amount The amount of tokens to borrow.\n     */\n    function borrow(uint256 amount) public onlyOwner {\n        if (reserve - amount < 0) {\n            revert lending_outOfReserve();\n        }\n        token.transfer(msg.sender, amount);\n    }\n\n    /**\n     * @notice Allows the owner to lend tokens to the contract.\n     * @param amount The amount of tokens to lend.\n     */\n    function lend(uint256 amount) public onlyOwner {\n        token.transferFrom(msg.sender, address(this), amount);\n        reserve += amount;\n    }\n\n    /**\n     * @notice Sets the borrowing APY.\n     * @param newAPY The new APY value.\n     */\n    function setBorrowingAPY(uint256 newAPY) public onlyOwner {\n        borrowingAPY = newAPY;\n    }\n\n    /**\n     * @notice Checks if enough time has passed for a user to farm yield again.\n     * @param user The address of the user.\n     * @return bool True if enough time has passed, false otherwise.\n     */\n    function isTime(address user) public view returns (bool) {\n        lastYieldFarmedTime[user];\n        uint256 currentStamp = block.timestamp;\n        if ((lastYieldFarmedTime[user] + 1 days) < currentStamp) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @notice Withdraws tokens from the reserve.\n     * This function allows the owner to withdraw tokens from the available reserve, reducing the reserve balance.\n     * @param amount The amount of tokens to withdraw from the reserve.\n     */\n    function withdraw(uint256 amount) public onlyOwner {\n        if (reserve - amount < 0) {\n            revert lending_reserveNotAvailable();\n        }\n        token.transfer(msg.sender, amount);\n        reserve -= amount;\n    }\n\n    /**\n     * @notice Calculates and returns the available yield for a user.\n     * This function updates the yield taken and farmed yield accordingly.\n     * @param user The address of the user farming yield.\n     * @param tokenAmount The amount of tokens used for calculating the user's share of the yield.\n     * @return uint256 The amount of yield available for the user.\n     */\n    function getYield(\n        address user,\n        uint256 tokenAmount\n    ) public onlyOwner returns (uint256) {\n        if (isTime(user) == false) {\n            revert lending_notEnoughTimePassed();\n        }\n        lastYieldFarmedTime[user] = block.timestamp; // Reentrancy guard\n        uint256 yieldSoFar = yieldTaken[user];\n        uint256 userLiquidity = (tokenAmount * 100) / amoutLended;\n        uint256 availableYield = ((yield -\n            ((yieldSoFar * 100) / userLiquidity)) * userLiquidity) / 100;\n\n        if (availableYield > yield - farmedYield) {\n            revert lending_notEnoughTimePassed(); // IN CASE THERE IS A LOT OF PEOPLE GETTING YIELD AT ONCE AND RATIOS GET CHANGED TOO MUCH\n        }\n        yieldTaken[msg.sender] += availableYield;\n        farmedYield += availableYield;\n        return availableYield;\n    }\n}\n"
    },
    "contracts/Lending/LendingTracker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\n// Importing necessary contracts and interfaces\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./Lending.sol\";\n\n// Custom error definitions for specific failure conditions\nerror lendingTracker_addressNotAllowed();\nerror lendingTracker_poolNotAvailable();\nerror lendingTracker_amountTooHigh();\nerror lendingTracker_receiptDoesntExist();\n\n/**\n * @title LendingTracker\n * @dev Manages lending, borrowing, and collateral operations for a decentralized finance platform.\n * Utilizes external price feeds for valuation and includes functionality for yield farming.\n * This contract is responsible for tracking user interactions with lending pools and their collateralized positions.\n */\ncontract LendingTracker {\n    // Events for logging various actions within the contract\n    event userBorrowed(address user, address tokenAddress, uint256 tokenAmount);\n    event userLended(address user, address tokenAddress, uint256 tokenAmount);\n    event userWithdrawnLendedTokens(\n        address user,\n        address tokenAddress,\n        uint256 tokenAmount\n    );\n    event userStakedCollateral(\n        address user,\n        address tokenAddress,\n        uint256 tokenAmount\n    );\n    event userUnstakedCollateral(\n        address user,\n        address tokenAddress,\n        uint256 tokenAmount\n    );\n    event userReturnedBorrowedToken(\n        address user,\n        address tokenAddress,\n        uint256 receiptId,\n        uint256 tokenAmount,\n        uint256 interest\n    );\n    event userFarmedYield(\n        address user,\n        address tokenAddress,\n        uint256 tokenAmount\n    );\n    event collateralTerminated(address user);\n\n    // Maximum Loan-to-Value (LTV) ratio for borrowing against collateral\n    int256 ltv = 75;\n\n    // Owner of the contract, set at deployment\n    address owner;\n\n    // Constructor sets the deploying address as the owner\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // Struct to hold lending pool and its associated price feed information\n    struct tokenPool {\n        Lending poolAddress; // ERC-20 Token address\n        address priceAddress; // Chainlink price feed\n    }\n\n    // Struct to track borrowing receipts for users\n    struct borrowReceipt {\n        address tokenAddress;\n        uint256 amount;\n        uint256 time;\n        uint256 apy;\n    }\n\n    // Mappings to track lending pools, user interactions, and collateral\n    mapping(address => tokenPool) public tokenToPool; // To find pool for specific ERC20 address\n\n    mapping(address => mapping(address => uint256)) public userLendedAmount; // Lended amout of specific token for user\n    mapping(address => address[]) public userLendedTokens; // All lended token addresses of user\n\n    mapping(address => mapping(address => uint256)) public collateral; // Collateral amount of specific token for user\n    mapping(address => address[]) public collateralTokens; // All collateralized token addresses of user\n\n    mapping(address => address[]) public borrowedTokens; // All borrowed token addresses of user\n    mapping(address => uint256) public borrowingId; // Current borrowing Id of the user, it increments with each borrow\n    mapping(address => mapping(address => uint256[])) public userBorrowReceipts; // All receipt ids for a certain token address of user\n    mapping(address => mapping(uint256 => borrowReceipt)) public borrowReceipts; // Id to receipt\n\n    /**\n     * @notice Adds a new token pool for lending and borrowing.\n     * @dev Deploys a new Lending contract for the token and registers it along with its price feed.\n     * @param tokenAddress Address of the token for the new lending pool.\n     * @param priceAddress Address of the Chainlink price feed for the token.\n     */\n    function addTokenPool(address tokenAddress, address priceAddress) public {\n        if (msg.sender != owner) {\n            revert lendingTracker_addressNotAllowed();\n        }\n        Lending newPool = new Lending(tokenAddress);\n        tokenToPool[tokenAddress] = tokenPool(newPool, priceAddress);\n    }\n\n    /**\n     * @notice Changes the price feed for a given token.\n     * @dev Allows the contract owner to update the price feed address in case of changes or migration.\n     * @param tokenAddress Address of the token whose price feed is being updated.\n     * @param priceAddress New address of the Chainlink price feed.\n     */\n    function changePriceFeed(\n        address tokenAddress,\n        address priceAddress\n    ) public {\n        // Checks if address is allowed to call this\n        if (msg.sender != owner) {\n            revert lendingTracker_addressNotAllowed();\n        }\n        // Checks if the pool exists\n        if (address(tokenToPool[tokenAddress].poolAddress) == address(0)) {\n            revert lendingTracker_poolNotAvailable();\n        }\n        tokenToPool[tokenAddress].priceAddress = priceAddress;\n    }\n\n    /**\n     * @notice Updates the borrowing APY for a specified token pool.\n     * @param tokenAddress Address of the token whose lending pool APY is to be changed.\n     * @param newAPY The new annual percentage yield for borrowing.\n     */\n    function changeBorrowingAPY(address tokenAddress, uint256 newAPY) public {\n        if (msg.sender != owner) {\n            revert lendingTracker_addressNotAllowed();\n        }\n        tokenToPool[tokenAddress].poolAddress.setBorrowingAPY(newAPY);\n    }\n\n    /**\n     * @notice Allows a user to borrow tokens from a specific lending pool.\n     * @dev The function checks for sufficient liquidity and adherence to the loan-to-value (LTV) ratio before permitting the borrow.\n     * Updates the user's borrow receipts to keep track of the borrowed amount and terms.\n     * @param tokenAddress The address of the token the user wishes to borrow.\n     * @param tokenAmount The amount of tokens the user wants to borrow.\n     */\n    function borrowToken(address tokenAddress, uint256 tokenAmount) public {\n        // Checks if the pool exists\n        if (address(tokenToPool[tokenAddress].poolAddress) == address(0)) {\n            revert lendingTracker_poolNotAvailable();\n        }\n        // Liquidity treshold, if ltv is too high\n        if (liquidityTreshold(msg.sender, tokenAddress, tokenAmount) >= ltv) {\n            revert lendingTracker_amountTooHigh();\n        }\n        // Borrows from the pool contract\n        tokenToPool[tokenAddress].poolAddress.borrow(tokenAmount); // Checks if there is enough reserve\n\n        // Maps the token address if needed\n        if (newTokenChecker(borrowedTokens[msg.sender], tokenAddress) == true) {\n            borrowedTokens[msg.sender].push(tokenAddress);\n        }\n        // Adds funds to a mapping\n        userBorrowReceipts[msg.sender][tokenAddress].push(\n            borrowingId[msg.sender]\n        );\n        borrowReceipts[msg.sender][borrowingId[msg.sender]] = borrowReceipt(\n            tokenAddress,\n            tokenAmount,\n            block.timestamp,\n            tokenToPool[tokenAddress].poolAddress.borrowingAPY()\n        );\n\n        // Transfers tokens to user\n        IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\n        // User receipt Id\n        borrowingId[msg.sender] += 1;\n\n        // Event\n        emit userBorrowed(msg.sender, tokenAddress, tokenAmount);\n    }\n\n    /**\n     * @notice Enables a user to lend tokens to a specific pool.\n     * @dev Transfers tokens from the user to the lending pool contract and updates the tracking of lent amounts.\n     * Requires token approval from the user to the LendingTracker contract.\n     * @param tokenAddress The address of the token being lent.\n     * @param tokenAmount The amount of tokens the user is lending.\n     */\n    function lendToken(address tokenAddress, uint256 tokenAmount) public {\n        // Checks if pool exists\n        if (address(tokenToPool[tokenAddress].poolAddress) == address(0)) {\n            revert lendingTracker_poolNotAvailable();\n        }\n        // Transfer and approve tokens\n        IERC20(tokenAddress).transferFrom(\n            msg.sender,\n            address(this),\n            tokenAmount\n        );\n        IERC20(tokenAddress).approve(\n            address(tokenToPool[tokenAddress].poolAddress),\n            tokenAmount\n        );\n        // Maps the token address if needed\n        if (\n            newTokenChecker(userLendedTokens[msg.sender], tokenAddress) == true\n        ) {\n            userLendedTokens[msg.sender].push(tokenAddress);\n        }\n        // Add funds to mapping\n        userLendedAmount[msg.sender][tokenAddress] += tokenAmount;\n        tokenToPool[tokenAddress].poolAddress.lend(tokenAmount);\n\n        // Event\n        emit userLended(msg.sender, tokenAddress, tokenAmount);\n    }\n\n    /**\n     * @notice Withdraws tokens previously lent to the lending pool by the user.\n     * @dev Ensures the user cannot withdraw more than they have lent. Adjusts the user's lent amount record accordingly.\n     * @param tokenAddress The address of the token to withdraw from the lending pool.\n     * @param tokenAmount The amount of tokens to withdraw.\n     */\n    function withdrawLendedToken(\n        address tokenAddress,\n        uint256 tokenAmount\n    ) public {\n        // Checks if pool exists\n        if (address(tokenToPool[tokenAddress].poolAddress) == address(0)) {\n            revert lendingTracker_poolNotAvailable();\n        }\n        // Checks if there is enough tokens in the pool\n        if (userLendedAmount[msg.sender][tokenAddress] < tokenAmount) {\n            revert lendingTracker_amountTooHigh();\n        }\n        userLendedAmount[msg.sender][tokenAddress] -= tokenAmount;\n        tokenToPool[tokenAddress].poolAddress.withdraw(tokenAmount);\n        // Transfer tokens to user\n        IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\n\n        // Event\n        emit userWithdrawnLendedTokens(msg.sender, tokenAddress, tokenAmount);\n    }\n\n    /**\n     * @notice Allows users to stake tokens as collateral for borrowing.\n     * @dev Transfers tokens from the user to this contract for collateralization. Updates the collateral tracking mappings.\n     * @param tokenAddress The address of the token being staked as collateral.\n     * @param tokenAmount The amount of the token to stake.\n     */\n    function stakeCollateral(address tokenAddress, uint256 tokenAmount) public {\n        // Checks if pool exists\n        if (address(tokenToPool[tokenAddress].poolAddress) == address(0)) {\n            revert lendingTracker_poolNotAvailable();\n        }\n        // Transfers tokens from user to the contract\n        IERC20(tokenAddress).transferFrom(\n            msg.sender,\n            address(this),\n            tokenAmount\n        );\n        // Maps the token address if needed\n        if (\n            newTokenChecker(collateralTokens[msg.sender], tokenAddress) == true\n        ) {\n            collateralTokens[msg.sender].push(tokenAddress);\n        }\n        // Adds the amount to mapping\n        collateral[msg.sender][tokenAddress] += tokenAmount;\n\n        //Event\n        emit userStakedCollateral(msg.sender, tokenAddress, tokenAmount);\n    }\n\n    /**\n     * @notice Permits users to withdraw their staked collateral, provided they have no outstanding loans.\n     * @dev Ensures that the withdrawal does not violate the loan-to-value (LTV) requirements.\n     * @param tokenAddress The address of the token to unstake.\n     * @param tokenAmount The amount of the token to unstake.\n     */\n    function unstakeCollateral(\n        address tokenAddress,\n        uint256 tokenAmount\n    ) public {\n        // Checks if amount is too high and if the user is borrowing any tokens\n        if (\n            collateral[msg.sender][tokenAddress] - tokenAmount < 0 &&\n            borrowedTokens[msg.sender].length > 0\n        ) {\n            revert lendingTracker_addressNotAllowed();\n        }\n        // Decreases amount in mapping\n        collateral[msg.sender][tokenAddress] -= tokenAmount;\n        // Transfers the tokens to user\n        IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\n        // Maps the token address if needed\n        if (collateral[msg.sender][tokenAddress] == 0) {\n            for (uint256 i; i < collateralTokens[msg.sender].length; i++) {\n                if (collateralTokens[msg.sender][i] == tokenAddress) {\n                    delete collateralTokens[msg.sender][i];\n                }\n            }\n        }\n\n        //Event\n        emit userUnstakedCollateral(msg.sender, tokenAddress, tokenAmount);\n    }\n\n    /**\n     * @notice Computes the current loan-to-value (LTV) ratio for a user's borrowed funds against their staked collateral.\n     * @dev Used to determine if a user's borrowings are within permissible limits. Can also factor in an additional amount\n     * being borrowed or provided as collateral.\n     * @param user The address of the user.\n     * @param additionalTokenAddress Optionally, the address of a token being considered for borrowing/collateral.\n     * @param tokenAmount Optionally, the amount of the additional token being considered.\n     * @return The LTV ratio as a percentage.\n     */\n    function liquidityTreshold(\n        address user,\n        address additionalTokenAddress,\n        uint256 tokenAmount\n    ) public view returns (int) {\n        // It checks the price in USD if collaterall falls below borrowed amount in usd + the apy till date, the collateral get terminated\n        int collateralUSD;\n        int borrowedUSD;\n        // If we want to calculate ltv with additional funds\n        if (\n            tokenAmount != 0 &&\n            tokenToPool[additionalTokenAddress].priceAddress != address(0)\n        ) {\n            int conversion = usdConverter(\n                tokenToPool[additionalTokenAddress].priceAddress\n            );\n            collateralUSD += conversion * int(tokenAmount);\n        }\n        for (uint256 i; i < collateralTokens[user].length; i++) {\n            address tokenAddress = collateralTokens[user][i];\n            uint256 amountOfToken = collateral[user][tokenAddress];\n            // Get conversion to USD\n            int conversion = usdConverter(\n                tokenToPool[tokenAddress].priceAddress\n            );\n            collateralUSD += conversion * int(amountOfToken);\n        }\n        for (uint256 i; i < borrowedTokens[user].length; i++) {\n            address tokenAddress = borrowedTokens[user][i];\n            uint256[] storage receiptIds = userBorrowReceipts[user][\n                tokenAddress\n            ];\n            for (uint256 a; a < receiptIds.length; a++) {\n                uint256 receiptTIME = borrowReceipts[msg.sender][receiptIds[a]]\n                    .time;\n                uint256 receiptAMOUNT = borrowReceipts[msg.sender][\n                    receiptIds[a]\n                ].amount;\n                address receiptAddress = borrowReceipts[msg.sender][\n                    receiptIds[a]\n                ].tokenAddress;\n                uint256 receiptAPY = borrowReceipts[msg.sender][receiptIds[a]]\n                    .apy;\n                uint256 borrowInterest = (receiptAMOUNT *\n                    receiptTIME *\n                    receiptAPY) / (365 days * 100);\n                int conversion = usdConverter(\n                    tokenToPool[receiptAddress].priceAddress\n                );\n                borrowedUSD += conversion * int(borrowInterest + receiptAMOUNT);\n            }\n        }\n        return (borrowedUSD * 100) / collateralUSD;\n    }\n\n    /**\n     * @notice Initiates the liquidation of a user's collateral if their LTV ratio exceeds the maximum permitted value.\n     * @dev Meant to be called by an external mechanism (like a keeper) that monitors LTV ratios.\n     * @param userAddress The address of the user whose collateral is being liquidated.\n     */\n    function terminateCollateral(address userAddress) public {\n        // Check if the ltv is too high, if it is not reverts\n        if (liquidityTreshold(userAddress, address(0), 0) <= ltv) {\n            revert lendingTracker_addressNotAllowed();\n        }\n        // terminate user collateral and share it between the lenders\n        for (uint256 i; i < collateralTokens[userAddress].length; i++) {\n            collateral[msg.sender][collateralTokens[userAddress][i]] = 0;\n            delete collateralTokens[msg.sender][i];\n        }\n        // Add swap on uniswap router or swap between pools\n\n        // Event\n        emit collateralTerminated(userAddress);\n    }\n\n    /**\n     * @notice Converts the token amount to its USD equivalent using Chainlink price feeds.\n     * @dev Utility function to assist in calculating collateral values and loan amounts.\n     * @param priceAddress Address of the Chainlink price feed for the token.\n     * @return int The USD value of the token amount based on the latest price feed data.\n     */\n    function usdConverter(address priceAddress) public view returns (int) {\n        (, int answer, , , ) = AggregatorV3Interface(priceAddress)\n            .latestRoundData();\n        return answer;\n    }\n\n    /**\n     * @notice Checks if a new token is not already tracked by the user's token array.\n     * @dev Utility function to prevent duplicate entries in user token arrays.\n     * @param userTokens Array of token addresses the user has interacted with.\n     * @param token Address of the token to check.\n     * @return bool True if the token is not in the array, false otherwise.\n     */\n    function newTokenChecker(\n        address[] memory userTokens,\n        address token\n    ) public pure returns (bool) {\n        bool newToken = true;\n        for (uint256 i; i < userTokens.length; i++) {\n            if (token == userTokens[i]) {\n                newToken = false;\n            }\n        }\n        return newToken;\n    }\n\n    /**\n     * @notice Claims yield for the user based on the tokens they have lent to the pool.\n     * @dev Calculates the yield based on the amount lent and the time passed, then transfers the yield to the user.\n     * @param tokenAddress The address of the token for which yield is being claimed.\n     */\n    function getYield(address tokenAddress) public {\n        uint256 yield = tokenToPool[tokenAddress].poolAddress.getYield(\n            msg.sender,\n            userLendedAmount[msg.sender][tokenAddress]\n        );\n        IERC20(tokenAddress).transfer(msg.sender, yield);\n\n        // Event\n        emit userFarmedYield(msg.sender, tokenAddress, yield);\n    }\n\n    /**\n     * @notice Allows a user to return borrowed tokens along with any accrued interest.\n     * @dev Calculates interest based on the borrowing APY and time elapsed since the token was borrowed.\n     * @param id The unique identifier of the borrow receipt.\n     * @param tokenAmount The amount of the borrowed token being returned.\n     */\n    function returnBorrowedToken(uint256 id, uint256 tokenAmount) public {\n        if (borrowReceipts[msg.sender][id].amount == 0) {\n            revert lendingTracker_receiptDoesntExist();\n        }\n        if (borrowReceipts[msg.sender][id].amount - tokenAmount < 0) {\n            revert lendingTracker_amountTooHigh();\n        }\n        uint256 receiptAPY = borrowReceipts[msg.sender][id].apy;\n        uint256 receiptTIME = borrowReceipts[msg.sender][id].time;\n        address tokenAddress = borrowReceipts[msg.sender][id].tokenAddress;\n\n        uint256 borrowInterest = (tokenAmount * receiptTIME * receiptAPY) /\n            (365 days * 100);\n\n        IERC20(tokenAddress).transferFrom(\n            msg.sender,\n            address(this),\n            tokenAmount + borrowInterest\n        );\n        borrowReceipts[msg.sender][id].amount -= tokenAmount;\n\n        // Event\n        emit userReturnedBorrowedToken(\n            msg.sender,\n            tokenAddress,\n            id,\n            tokenAmount,\n            borrowInterest\n        );\n    }\n}\n\n// Need to do:\n// Swap of tokens after termination of collateral(or what to do if not swapping)\n// If yield number gets too high(uint256), we open up a new pool with same stats\n// If we make new pool with same token and price address we need to restore lended amount for each person(refreshPool())\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}